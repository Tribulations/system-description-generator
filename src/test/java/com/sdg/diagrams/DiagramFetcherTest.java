package com.sdg.diagrams;

import com.sdg.llm.GeminiApiClient;
import com.sdg.llm.LLMService;
import io.reactivex.rxjava3.core.Single;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;

class DiagramFetcherTest {
    @Test
    void shouldGenerateFiveDiagrams() throws InterruptedException {
        DiagramFetcher diagramFetcher = new DiagramFetcher(new LLMService(new GeminiApiClient()));
        List<String> validatedDiagrams = diagramFetcher.generatePlantUMLDiagrams(highLevelDescription);

        assertEquals(5, validatedDiagrams.size());
    }

    @Test
    void shouldCorrectInvalidDiagram() {
        // Check that diagram is invalid
        assertThrows(RuntimeException.class, () ->
                PlantUMLValidator.validatePlantUMLSyntax(PlantUMLTestData.INVALID_DIAGRAM_SYNTAX));

        // Correct it
        DiagramFetcher diagramFetcher = new DiagramFetcher(new LLMService(new GeminiApiClient()));

        Single<List<String>> correctedDiagramSingle = diagramFetcher
                .validateAndCorrectPlantUMLDiagrams(List.of(PlantUMLTestData.INVALID_DIAGRAM_SYNTAX));
        String correctedDiagram = correctedDiagramSingle.blockingGet().getFirst();

        // Validate that the diagram was corrected
        assertDoesNotThrow(() -> PlantUMLValidator.validatePlantUMLSyntax(correctedDiagram));
    }


    private static final String highLevelDescription = """
            Here's a summary of the Java maze solver system:
            
            1.  **System Purpose:** The system solves mazes, likely by visualizing the solution path.
            
            2.  **Key Components & Responsibilities:**
                *   `MainView`: The main user interface, responsible for displaying the maze and interacting with the user. It handles user actions like browsing for maze images and triggering the solving process.
                *   `MainController`: Acts as the orchestrator, connecting the view and the algorithm components. It manages the maze solving process and updates the view with the solution.
                *   `MazeView`: Responsible for rendering the maze image and visualizing the solution path. It handles mouse clicks for setting start and end points.
                *   `MazeGenerator`: Creates maze images from different sources.
                *   `Algorithm` (BaseAlgorithm, AStar, DijkstraPriorityQueue, AStarOOP, DijkstraArrayList): Implements different maze-solving algorithms.
                *   `MazeGrid`: Represents the maze as a grid data structure.
            
            3.  **Core Technologies & Dependencies:**
                *   Java (programming language)
                *   Swing (GUI framework)
                *   OpenCV (image processing library)
            
            4.  **Architecture:** The system follows a Model-View-Controller (MVC) architecture. The `MainView` and `MazeView` represent the view, `MainController` acts as the controller, and `MazeGrid`, `MazeGenerator`, and the algorithm classes represent the model.
            
            5.  **Data Flow:**
                1.  The `MainView` receives user input (e.g., selecting a maze image, setting start/end points).
                2.  The `MainView` notifies the `MainController` about these actions.
                3.  The `MainController` retrieves the maze image (using `MazeGenerator`) and represents it as a `MazeGrid`.
                4.  The `MainController` selects and invokes a maze-solving algorithm (e.g., A*, Dijkstra) on the `MazeGrid`.
                5.  The algorithm calculates the solution path.
                6.  The `MainController` updates the `MazeView` with the solution path.
                7.  The `MazeView` renders the maze and the solution path to the user.
            vice`. The extracted information is used to build a knowledge graph managed by `KnowledgeGraphService` and stored in a Neo4j database via `GraphDatabaseOperations`. Diagrams are generated by `DiagramManager` based on the analyzed code.
            
            5.  **Data Flow:** User input (Java code or project path) is received by the `InputController`. The `InputHandler` processes the input. The `ASTAnalyzer` parses the code and extracts information. This information is used to create nodes and relationships in the knowledge graph, which is stored in Neo4j. The `DiagramManager` queries the knowledge graph or directly uses the analyzed code to generate diagrams, which are then displayed in the `MainView`. The `LLMService` may be involved in the analysis process, providing additional insights or generating diagram code.
            ams using PlantUML.
                6.  The generated diagrams are displayed in the `MainView`.
                7.  LLMs are used by `LLMService` and its clients to process code and generate diagrams.
            s data from the knowledge graph and generates diagrams using PlantUML.
                6.  The generated diagrams are displayed in the `MainView`.
                7.  `GraphDataToJsonConverter` converts graph data to JSON format.
                8.  `LLMService` interacts with LLMs for code analysis.""";

}
